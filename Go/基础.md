## 依赖包管理工具

- dep
  未完待续...
- go vendor
  未完待续...
- glide
  未完待续...
- **go modules**
  
  伴随Go 1.11出现，**官方推荐**

## go mod 命令
- `go mod tidy`
  
  拉取缺少的模块，移除不用的模块
- `go mod vandor`
  
  将依赖复制到vendor下
- `go mod download`
  
  下载依赖包
- `go mod verify`
  
  检测依赖
- `go mod graph`
  
  打印模块依赖图

## 切片

### 切片就像数组的引用

### 切片拥有 *长度* 和 *容量*
- 切片的长度就是它所包含的元素个数。
- 切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。
- 切片 s 的长度和容量可通过表达式 `len(s)` 和 `cap(s)` 来获取。

### 切片可以用内建函数 `make` 来创建，这也是创建动态数组的方式。`make` 函数会分配一个元素为零值的数组并返回一个引用了它的切片：
``` go
a := make([]int, 5)  // len(a)=5

// 要指定它的容量，需向 make 传入第三个参数：
b := make([]int, 0, 5) // len(b)=0, cap(b)=5
b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4
```

### 向切片追加元素
append 的第一个参数 s 是一个元素类型为 T 的切片，其余类型为 T 的值将会追加到该切片的末尾。append 的结果是一个包含原切片所有元素加上新添加元素的切片。当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个(**cap值翻倍**)更大的数组。返回的切片会指向这个新分配的数组。
``` go
import "fmt"

func main() {
	var s []int
    printSlice(s)
    // len=0 cap=0 []

    // cap不够用——>cap翻倍——>cap=2
	s = append(s, 0)
    printSlice(s)
    // len=1 cap=2 [0]

    // cap够用——>保持不变——>cap=2
	s = append(s, 1)
    printSlice(s)
    // len=2 cap=2 [0 1]

    // cap不够用——>cap翻倍——>cap=8
	s = append(s, 2, 3, 4)
    printSlice(s)
    // len=5 cap=8 [0 1 2 3 4]

    // cap够用——>cap保持不变——>cap=8
    s = append(s, 5, 6, 7)
    printSlice(s)
    // len=8 cap=8 [0 1 2 3 4 5 6 7]
}

func printSlice(s []int) {
	fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}
```